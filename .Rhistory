data <- read.csv('~/Desktop/House_Price_Prediction/data.csv',
stringsAsFactors = TRUE)
str(data)
summary(data)
data2 <- subset(data, price > 0)
data2$waterfront <- as.factor(data2$waterfront)
data2 <- subset(data2, select = -c(sqft_above,sqft_basement, view,
date, street, statezip, country))
summary(data2)
data2 <- subset(data2, price != 7800) #Low outlier found
boxplot(data2$price) #with outliers
#identify and remove outliers. R does this using the 1.5*IQR criterion
outliers <- boxplot(data2$price, plot=FALSE)$out
data2 <- data2[-which(data2$price %in% outliers),]
hist(data2$price)
plot(density(log(data2$price)))
# Create Seattle data frame
seattle.df = subset(data2, city == "Seattle")
seattle.df = subset(seattle.df, select = -c(city))
dim(seattle.df)
summary(seattle.df)
# Drop waterfront
seattle.df = subset(seattle.df, select = -c(waterfront))
# Price
boxplot(seattle.df$price)
summary(seattle.df$price)
hist(seattle.df$price)
plot(density(log(seattle.df$price)))
hist(seattle.df$bedrooms)
hist(seattle.df$bathrooms)
hist(seattle.df$sqft_living)
hist(seattle.df$sqft_lot)
hist(seattle.df$floors)
hist(seattle.df$condition)
hist(seattle.df$yr_built)
hist(seattle.df$yr_renovated)
# Relationships between response and predictors
par(mfrow = c(2, 2))
plot(price ~ bedrooms, data = seattle.df, main="Price vs Bedrooms", lwd=2)
abline(lm(price~bedrooms, data=seattle.df),col="red",lwd=2)
plot(price ~ bathrooms, data = seattle.df, main="Price vs Bathrooms", lwd=2)
abline(lm(price~bathrooms, data=seattle.df),col="red",lwd=2)
plot(price ~ sqft_living, data = seattle.df, main="Price vs Sqft_living", lwd=2)
abline(lm(price~sqft_living, data=seattle.df),col="red",lwd=2)
plot(price ~ sqft_lot, data = seattle.df, main="Price vs Sqft_lot", lwd=2)
abline(lm(price~sqft_lot, data=seattle.df),col="red",lwd=2)
plot(price ~ floors, data = seattle.df, main="Price vs Floors", lwd=2)
abline(lm(price~floors, data=seattle.df),col="red",lwd=2)
plot(price ~ condition, data = seattle.df, main="Price vs Condition", lwd=2)
abline(lm(price~condition, data=seattle.df),col="red",lwd=2)
plot(price ~ yr_built, data = seattle.df, main="Price vs Year built", lwd=2)
abline(lm(price~yr_built, data=seattle.df),col="red",lwd=2)
plot(price ~ yr_renovated, data = seattle.df, main="Price vs Year renovated", lwd=2)
abline(lm(price~yr_renovated, data=seattle.df),col="red",lwd=2)
library(ggplot2)
set.seed(1)
# Training and test sets
train = sample(1:nrow(seattle.df), nrow(seattle.df)*0.8) # 80/20 split
test = (-train)
price.test = seattle.df$price[test]
# Dataframes
train.df = data.frame(seattle.df[train,])
test.df = data.frame(seattle.df[test,])
seattle_full.lm = lm((price) ~ ., data=seattle.df, subset=train)
summary(seattle_full.lm)
# Test MSE
lm_full.pred = predict(seattle_full.lm, test.df, type=c("response"))
err.lm_full = mean((lm_full.pred-test.df$price)^2)
err.lm_full
rmse.lm.full = sqrt(err.lm_full)
# Log-transformed price
seattle_full.lmlog = lm(log(price) ~ ., data=seattle.df, subset=train)
summary(seattle_full.lmlog)
seattle.lm2 = update(seattle_full.lm, ~ . -yr_renovated)
summary(seattle.lm2)
#Test MSE
lm.pred = predict(seattle.lm2, test.df, type=c("response"))
err.lm = mean((lm.pred-test.df$price)^2)
err.lm
# Checking multicollinearity
pairs(seattle.df)
cor(seattle.df[,c("price","bedrooms","bathrooms", "sqft_living", "sqft_lot","floors", "condition", "yr_built", "yr_renovated")])
# Need linear relationship between response and predictors
# Check if log-transform yields linear relationship
plot(price ~ I(log(sqft_living)), data = seattle.df, main="Price vs Sqft_living", lwd=2)
abline(lm(price~I(log(sqft_living)), data=seattle.df),col="red",lwd=2)
plot(price ~ I(log(sqft_lot)), data = seattle.df, main="Price vs Sqft_lot", lwd=2)
abline(lm(price~I(log(sqft_lot)), data=seattle.df),col="red",lwd=2)
plot(price ~ I(log(yr_built)), data = seattle.df, main="Price vs Year built", lwd=2)
abline(lm(price~I(log(yr_built)), data=seattle.df),col="red",lwd=2)
# Checking residuals
plot(seattle.lm2)
# Likelihood ratio test
anova(seattle.lm2, seattle_full.lm, test="LRT")
# Backward subset selection
library(MASS)
stepAIC(seattle_full.lm) # stepwise backward selection using AIC
#Transform sqft_living
seattle.lm3 = update(seattle_full.lm, ~ . -yr_renovated -sqft_living + I(log(sqft_living)) - sqft_lot + I(log(sqft_lot)))
summary(seattle.lm3)
# Test MSE
lm.pred = predict(seattle.lm3, test.df, type=c("response"))
err.lm = mean((lm.pred-test.df$price)^2)
err.lm
rmse = sqrt(err.lm)
rmse
plot(lm.pred, test.df$price, xlab="Predicted price", ylab="Actual price", main = "Actual vs. Predicted House Prices")
abline(lm(test.df$price~lm.pred,
data=seattle.df),col="red",lwd=2)
data <- read.csv('~/Desktop/House_Price_Prediction/data.csv',
stringsAsFactors = TRUE)
str(data)
summary(data)
data2 <- subset(data, price > 0)
data2$waterfront <- as.factor(data2$waterfront)
data2 <- subset(data2, select = -c(sqft_above,sqft_basement, view,
date, street, statezip, country))
summary(data2)
data2 <- subset(data2, price != 7800) #Low outlier found
boxplot(data2$price) #with outliers
#identify and remove outliers. R does this using the 1.5*IQR criterion
outliers <- boxplot(data2$price, plot=FALSE)$out
data2 <- data2[-which(data2$price %in% outliers),]
hist(data2$price)
plot(density(log(data2$price)))
# Create Seattle data frame
seattle.df = subset(data2, city == "Seattle")
seattle.df = subset(seattle.df, select = -c(city))
dim(seattle.df)
summary(seattle.df)
# Drop waterfront
seattle.df = subset(seattle.df, select = -c(waterfront))
# Price
boxplot(seattle.df$price)
summary(seattle.df$price)
hist(seattle.df$price)
plot(density(log(seattle.df$price)))
hist(seattle.df$bedrooms)
hist(seattle.df$bathrooms)
hist(seattle.df$sqft_living)
hist(seattle.df$sqft_lot)
hist(seattle.df$floors)
hist(seattle.df$condition)
hist(seattle.df$yr_built)
hist(seattle.df$yr_renovated)
# Relationships between response and predictors
par(mfrow = c(2, 2))
plot(price ~ bedrooms, data = seattle.df, main="Price vs Bedrooms", lwd=2)
abline(lm(price~bedrooms, data=seattle.df),col="red",lwd=2)
plot(price ~ bathrooms, data = seattle.df, main="Price vs Bathrooms", lwd=2)
abline(lm(price~bathrooms, data=seattle.df),col="red",lwd=2)
plot(price ~ sqft_living, data = seattle.df, main="Price vs Sqft_living", lwd=2)
abline(lm(price~sqft_living, data=seattle.df),col="red",lwd=2)
plot(price ~ sqft_lot, data = seattle.df, main="Price vs Sqft_lot", lwd=2)
abline(lm(price~sqft_lot, data=seattle.df),col="red",lwd=2)
plot(price ~ floors, data = seattle.df, main="Price vs Floors", lwd=2)
abline(lm(price~floors, data=seattle.df),col="red",lwd=2)
plot(price ~ condition, data = seattle.df, main="Price vs Condition", lwd=2)
abline(lm(price~condition, data=seattle.df),col="red",lwd=2)
plot(price ~ yr_built, data = seattle.df, main="Price vs Year built", lwd=2)
abline(lm(price~yr_built, data=seattle.df),col="red",lwd=2)
plot(price ~ yr_renovated, data = seattle.df, main="Price vs Year renovated", lwd=2)
abline(lm(price~yr_renovated, data=seattle.df),col="red",lwd=2)
library(ggplot2)
set.seed(1)
# Training and test sets
train = sample(1:nrow(seattle.df), nrow(seattle.df)*0.8) # 80/20 split
test = (-train)
price.test = seattle.df$price[test]
# Dataframes
train.df = data.frame(seattle.df[train,])
test.df = data.frame(seattle.df[test,])
seattle_full.lm = lm((price) ~ ., data=seattle.df, subset=train)
summary(seattle_full.lm)
# Test MSE
lm_full.pred = predict(seattle_full.lm, test.df, type=c("response"))
err.lm_full = mean((lm_full.pred-test.df$price)^2)
err.lm_full
rmse.lm.full = sqrt(err.lm_full)
# Log-transformed price
seattle_full.lmlog = lm(log(price) ~ ., data=seattle.df, subset=train)
summary(seattle_full.lmlog)
seattle.lm2 = update(seattle_full.lm, ~ . -yr_renovated)
summary(seattle.lm2)
#Test MSE
lm.pred = predict(seattle.lm2, test.df, type=c("response"))
err.lm = mean((lm.pred-test.df$price)^2)
err.lm
# Checking multicollinearity
pairs(seattle.df)
cor(seattle.df[,c("price","bedrooms","bathrooms", "sqft_living", "sqft_lot","floors", "condition", "yr_built", "yr_renovated")])
# Need linear relationship between response and predictors
# Check if log-transform yields linear relationship
plot(price ~ I(log(sqft_living)), data = seattle.df, main="Price vs Sqft_living", lwd=2)
abline(lm(price~I(log(sqft_living)), data=seattle.df),col="red",lwd=2)
plot(price ~ I(log(sqft_lot)), data = seattle.df, main="Price vs Sqft_lot", lwd=2)
abline(lm(price~I(log(sqft_lot)), data=seattle.df),col="red",lwd=2)
plot(price ~ I(log(yr_built)), data = seattle.df, main="Price vs Year built", lwd=2)
abline(lm(price~I(log(yr_built)), data=seattle.df),col="red",lwd=2)
# Checking residuals
plot(seattle.lm2)
# Likelihood ratio test
anova(seattle.lm2, seattle_full.lm, test="LRT")
# Backward subset selection
library(MASS)
stepAIC(seattle_full.lm) # stepwise backward selection using AIC
#Transform sqft_living
seattle.lm3 = update(seattle_full.lm, ~ . -yr_renovated -sqft_living + I(log(sqft_living)) - sqft_lot + I(log(sqft_lot)))
summary(seattle.lm3)
# Test MSE
lm.pred = predict(seattle.lm3, test.df, type=c("response"))
err.lm = mean((lm.pred-test.df$price)^2)
err.lm
rmse = sqrt(err.lm)
rmse
plot(lm.pred, test.df$price, xlab="Predicted price", ylab="Actual price", main = "Actual vs. Predicted House Prices")
abline(lm(test.df$price~lm.pred,
data=seattle.df),col="red",lwd=2)
